# 1. Условие

Построить дерево в соответствии со своим вариантом задания.
Вывести его на экран в виде дерева. Реализовать основные операции
работы с деревом: обход дерева, включение, исключение и поиск узлов.
Сравнить эффективность алгоритмов сортировки и поиска в зависимости
от высоты деревьев и степени их ветвления.

В текстовом файле содержатся целые числа. Построить двоичное дерево из чисел файла.
Вывести его на экран в виде дерева. Определить количество узлов дерева на каждом уровне.
Добавить число в дерево и в файл. Сравнить время добавления чисел в указанные структуры.

# 2. Описание ТЗ

## 2.1 Исходные данные и результаты

**Входные данные**

1) Значение элемента (целое число)
2) Целое число — номер команды (от 0 до 11; См. [Описание задачи](#22-описание-задачи-реализуемой-программой));

**Выходные данны**

1) Дерево в 2D представлении
2) Результат поиска узла
3) Информация о количестве узлов на каждом уровне дерева
4) Результат эксперимента

## 2.2 Описание задачи, реализуемой программой

Программа реализует интерфейс для взаимодействия с симуляцией обработки очереди, позволяющий выполнить
следующие действия:

> Номер перечисления соответствует номеру команды в программе

0) Выход
1) Напечатать дерево
2) Добавить элемент в дерево
3) Найти элемент в дереве
4) Удалить элемент из дерева
5) Подсчитать количество узлов на каждом уровне дерева
6) Добавить элемент в файл
7) Добавить элемент и в дерево и в файл
8) Прямой обход дерева
9) Центрированный обход дерева
10) Обратный обход дерева
11) Провести замеры операции вставки
12) Провести замеры зависимости от высоты и ветвления

## 2.3 Способ обращения к программе

Взаимодействие с программой происходит через консольный интерфейс, входные данные вводятся пользователем с клавиатуры
Запуск программы из рабочей директории:

```shell
./app.exe
```

## 2.4 Описание возможных аварийных ситуаций и ошибок пользователя

Аварийные ситуации могут возникнуть только в случае невозможности выделения памяти.

> В программе предусмотренна защита от неправильного ввода, поэтому она не завершится аварийно в этом случае.

# 3. Внутренние структуры данных

Двоичное дерево поиска

```c++
typedef struct tree_node tree_node_t;

struct tree_node
{
    int key;
    tree_node_t *left;
    tree_node_t *right;
};
```

# 4. Описание алгоритма

## Алгоритм добавления:

```
Функция insert(node, key)
    Если node равен NULL
        Создать новый узел с ключом key
        Вернуть новый узел
    Конец если

    Если key < node.value
        Если node.left равен NULL
            node.left ← создать новый узел с ключом key
        Иначе
            Вызвать insert(node.left, key)
        Конец если
    Иначе если key > node.value
        Если node.right равен NULL
            node.right ← создать новый узел с ключом key
        Иначе
            Вызвать insert(node.right, key)
        Конец если
    Конец если

    Вернуть node
Конец функции
```

## Алгоритм поиска:

```
Функция search(node, key)
    Если node равен NULL
        Вернуть NULL  // Элемент не найден
    Конец если

    Если key = node.value
        Вернуть node  // Элемент найден
    Конец если

    Если key < node.value
        Вернуть search(node.left, key)  // Поиск в левом поддереве
    Иначе
        Вернуть search(node.right, key)  // Поиск в правом поддереве
    Конец если
Конец функции
```

## Алгоритм удаления:

```
Функция delete(node, key)
    Если node равен NULL
        Вернуть NULL  // Узел для удаления не найден
    Конец если

    Если key < node.value
        node.left ← deleteNode(node.left, key)  // Удаление в левом поддереве
    Иначе если key > node.value
        node.right ← deleteNode(node.right, key)  // Удаление в правом поддереве
    Иначе  // Узел найден
        Если node.left равен NULL
            Вернуть node.right  // Возвращаем правое поддерево
        Иначе если node.right равен NULL
            Вернуть node.left  // Возвращаем левое поддерево
        Иначе
            // Найти наибольший узел в левом поддереве
            successor ← findMax(node.right)
            node.value ← successor.value  // Заменить значение текущего узла
            node.left ← deleteNode(node.left, successor.value)  // Удалить дубликат
        Конец если
    Конец если

    Вернуть node
Конец функции

Функция findMax(node)
    Пока node.right не равен NULL
        node ← node.right
    Конец пока
    Вернуть node
Конец функции
```

# 5. Основные функции

Напечатать дерево

```c++
void process_show_tree(tree_node_t *root);
```

---
Вставка в дерево

```c++
void process_tree_insert(tree_node_t *root);
```

---
Удаление из дерева

```c++
void process_tree_remove(tree_node_t **root);
```

---
Поиск по дереву

```c++
void process_tree_find(tree_node_t *root);
```

---
Добавление в файл

```c++
void process_file_insert(void);
```

---
Вставка и в дерево и в файл

```c++
void process_insert_both(tree_node_t *root);
```

---
Прямой обход дерева

```c++
void process_tree_pre_order(tree_node_t *root);
```

---
Центрированный обход дерева

```c++
void process_tree_in_order(tree_node_t *root);
```

---
Обратный обход дерева

```c++
void process_tree_post_order(tree_node_t *root);
```

---
Подсчет узлов на каждом уровне

```c++
void process_count_nodes_in_each_level(tree_node_t *root);
```

---
Провести замеры операции добавления

```c++
void process_show_stat_insert(void);
```

---
Провести замеры зависимости

```c++
void process_show_stat(void);
```

---

# 6. Оценка эффективности

Из замеров видно, что если дерево сбалансировано, среднее время поиска в нем примерно одинаково для любой глубины, а для
вырожденных в список среднее время линейно растет в зависимости от глубины, хотя при этом количество элементов на
несколько порядков меньше. Время сортировки также растет с глубиной, что неудивительно, ведь оно напрямую зависит от
количества элементов в дереве.

# 7. Контрольные вопросы

## 1. Что такое дерево?

Дерево – это нелинейная структура данных, используемая для представления иерархических связей, имеющих отношение «один
ко многим».

## 2. Как выделяется память под представление деревьев?

Зависит от вида дерева: если дерево на узлах, то подобно связному списку память под узлы выделяется по мере их
добавления, если дерево на массиве - то память выделяется сразу под максимальный размер массива

## 3. Какие бывают типы деревьев?

**По структуре деревья бывают**

- Бинарные
- Двоичные деревья поиска
- Сбалансированные деревья
- B-деревья
- N-арные деревья

Двоичные деревья поиска в свою очередь бывают самобаллансирующимися, например:

- AVL
- Красно-черные деревья

**По типу представления в памяти бывают**

- Связные (узлы и указатели)
- На массиве

## 4. Какие стандартные операции возможны над деревьями?

- Вставка
- Поиск
- Удаление
- Прямой обход
- Центрированный (симметричный) обход
- Обратный обход

## 5. Что такое дерево двоичного поиска?

Дерево двоичного поиска — это структура данных, представляющая собой дерево, в котором каждый узел имеет не более двух
потомков, называемых левым и правым поддеревьями. В дереве двоичного поиска соблюдается определённое свойство, которое
упрощает операции поиска, вставки и удаления элементов.

# 8. Выводы

Бинарные деревья идеально подходят для задач, где необходимо хранить данные с возможностью быстрого поиска, добавления и удаления
элементов. Основным преимуществом бинарных деревьев является логарифмическая сложность операций поиска, вставки и
удаления, что делает их более эффективными по сравнению с линейными структурами данных, такими как массивы и списки.

Особенно полезны бинарные деревья в следующих случаях:

- **Поиск и сортировка:**\
  Деревья обеспечивают быстрый доступ к данным, что идеально подходит для реализации таких структур,
  как бинарные деревья поиска (BST), которые поддерживают элементы в отсортированном порядке.

- **Рекурсивные алгоритмы:**\
Бинарные деревья естественно подходят для рекурсивных задач, таких как обход дерева или решение
задач с использованием дерева решений.

Использование бинарных деревьев дает значительное улучшение производительности при работе с большими объемами данных,
позволяет эффективно выполнять операции поиска, вставки и удаления, а также удобно моделирует отношения "
родитель-потомок".






